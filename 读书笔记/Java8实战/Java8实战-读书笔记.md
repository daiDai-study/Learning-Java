# Java8实战-读书笔记

## 第零部分 相关资源
[书中实例代码](https://github.com/java8/Java8InAction)

### 1、重要概念
+ 事件处理器
+ 回调函数

## 第一部分 基础知识

> 目的：对 Lambda 表达式有充分的了解，编写更加简洁和灵活的代码。

## 第1章 为什么要关心 Java 8

> 总结 Java 8 的主要变化：Lambda 表达式、方法引用、流和默认方法。

[Java 版本--摘自 wiki](https://zh.wikipedia.org/wiki/Java%E7%89%88%E6%9C%AC%E6%AD%B7%E5%8F%B2)

![Java 版本](./imgs/Java版本历史.png)

在众多的版本更新中，Java 8 版本无疑是影响最深远的一个。它增加的新特性不仅让开发人员可以编写成更为简洁和清晰的代码，而且其对硬件也有影响（能够更简单地使用多核处理器）。

+ Strean API：支持数据处理的并行操作
+ 用行为参数化把代码传递给方法（Lambda、方法引用）：当写了两个只有几行代码不同的方法时，可以把不同的那部分代码作为参数传递进入即可

### 1.1 Java 怎么还在变

> 语言需要不断改进以跟进硬件的更新或满足程序员的期待，Java必须通过增加能够被人使用的新功能来改进，使得Java在整个编程语言生态系统中占据重要位置。

**3个概念**：
+ 流处理：类似与 Unix 命令行允许多个命令程序通过管道连接在一起
+ 用行为参数化把代码传递给方法：让**做什么**和**怎么做**区分开来
+ 并行和共享的可变数据：并行只有在假定你的代码的多个副本可以独立工作（即没有共享的可变数据）时才能进行

### 1.2 Java 中的函数

> 编程语言中的**函数**通常是指**方法**

在 Java（或其他面向对象）编程语言中，由于存在对象，所以会出现静态方法和实例（对象）方法

Java 中常见概念有：值（原始类型值、引用类型值）、方法、类等。在 Java 8 之前，值为一等公民（在程序执行期间可以传递的），而方法和类等则是二等公民（在程序执行期间不能传递）。Java 8 中的新特性（方法引用、Lambda）则将 Java 中的方法由二等公民变成了一等公民（*或者也可以说，将方法作为值*）。

与用对象引用（new 创建）传递对象类似，方法引用（如 File::isHidden）可以传递方法。使用方法引用时，需要预先知道类名和方法名，在不清楚这些条件或者方法内代码长度短的情况下，可以使用 Lambda（匿名函数）替代。 

### 1.3 流

+ 外部迭代：使用集合（Collection API）时，自己用for（或 for-each）循环迭代元素再处理元素；
+ 内部迭代：有了流（Stream API），数据迭代和处理都在库内部进行；

Java 8 使用流解决了两个问题：集合处理时的套路和晦涩，以及难以利用多核。在学习了 Java 8 之后，可以结合 Collection 和 Stream 处理集合，其中 Collection 主要用于存储和访问数据，Stream 用于描述对数据的计算（处理数据）。

### 1.4 默认方法

> 默认方法（default 关键字）的加入主要是为了支持库设计师，让他们能够写出更容易改进的接口。

问题：在 Java 8 之前，可能会更新一个接口（如，给接口新增了一个方法），然后发现需所有实现它的类也必须要更新（实现的类必须为其提供一个实现，这必然修改工作非常重大），这会导致严重问题，是一个逻辑灾难。

解决：Java 8 提供的默认方法，可以让实现类不是必须实现所有的接口方法。这为接口设计者提供了一个扩充接口的方式，而不会破坏现有的代码。

新的问题：一个类可以实现多个接口，如果其中多个接口都有默认实现，意味着 Java 中有了某种形式的多重继承，怎么解决？？？

### 1.5 来自函数式编程的其他好思想

+ Optional<T> 类如何避免出现**空指针**异常：该类中有方法来明确处理值不存在的情况
+ 模式匹配：不懂？？


## 第2章 通过行为参数化传递代码

> 了解行为参数化（一种软件开发模式）

### 1、为什么需要行为参数化

> 应对不断变化的需求，将**做什么**和**怎么做**区分开，也意味着某个方法可以接受不同的行为作为参数然后去执行

### 2、行为参数化的概念

> 行为参数化 != 将方法作为值传递给方法
> 
> Java 8 之前可以通过多态或匿名类实现行为参数化

### 3、行为参数化在 Java 中的演变

![行为参数化](./imgs/行为参数化.png)

0. 一般方式（建多个方法）
   + 无法应对复杂查询，当有新的需求时，需要新添加一个方法，而且代码（迭代行为）重复
1. 策略设计模式（多态）
   + 优点：去除了迭代代码的重复，也将做什么和怎么做区分开了，便于扩展新需求
   + 缺点：每次添加一个新需求，都需要新建一个类，代码还是很臃肿 == 声明了很多只需要实例化一次的类
2. 匿名类（去除实现类的声明，可以当用户在使用方法的同时直接声明和实例化一个类）
   + 优点：代码更加简洁了
   + 缺点：代码还是包含许多模板代码，而且代码还不够语义化
   + 注意：匿名类中的 this 指向匿名类当前实例
3. Lambda
   + 优秀


## 第3章

> 全面解释 Lambda 表达式和方法引用

### 1、如何构建 Lambda 表达式
> 可以把 Lambda 表达式可以理解为简洁表示可传递的匿名函数的一种方法：没有名称，有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。

#### 1.1 Lambda 表达式的特点
+ 匿名：Lambda 不像普通方法那样有一个明确的名称
+ 函数：Lambda 函数不像方法那样属于某个特定的类，但和方法一样，有参数列表、函数主体、返回类型，还可能有可以抛出的异常泪飙
+ 传递：Lambda 表达式可以作为参数传递给方法或存储在变量中
+ 简洁：无需像匿名类那样写很多模板代码

#### 1.2 Lambda 表达式的三个部分
+ 参数列表
+ 箭头：箭头 `->` 把参数列表和 Lambda 主体分隔开
+ Lambda 主体：可以是一个表达式（会隐含 `return` 语句，表达式的值同时也将作为返回值），也可以是一个代码块（此时，如果要返回值，必须通过 `return` 语句显式表示）

```
(parameters) -> expression
(parameters) -> {statements;}
```

### 2、Lambda 表达式的使用场合

> Lambda 表达式只可以使用在函数式接口上

#### 2.1 函数式接口

> 函数式接口就是只定义一个抽象方法的接口，一般会为该接口添加 `@FunctionalInterface` 注解（推荐但不是必需的）

在有个函数式接口之后，Lambda 表达式允许直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体来说，是函数式接口的一个具体实现的实例）。

#### 2.2 函数描述符

> 函数式接口的抽象方法的签名基本上就是 Lambda 表达式的签名，我们可以把这种签名叫做函数描述符。

可以使用一种特殊表示法来记录函数描述符：`(parameterTypeList) -> returnType`，举例如下：
+ `() -> void`：什么也不接受什么也不返回（void）的函数
+ `(Apple, Apple) -> int`：接受两个Apple为参数并返回int的函数

### 3、如何使用 Lambda

#### 3.1 重构现有方法

1. 行为参数化：查看现有方法，提取现有方法中代码不同的部分，并总结该部分代码的输入和输出
2. 定义函数式接口：定义函数式接口及其抽象方法，输入作为抽象方法的参数列表，输出作为抽象方法的返回值
3. 执行行为：使用函数式接口作为现有方法的新增参数，并将抽象方法的调用替换提取的部分代码，从而重构现有方法
4. 传递行为（Lambda）：使用 Lambda 表达式调用重构的方法来执行代码

#### 3.2 使用 Java API 提供的函数式接口

常用函数式接口：
+ `Predicate<T>`（test）：`(T) -> boolean`
+ `Consumer<T>`（accept）：`(T) -> void`
+ `Function<T,R>`（apply）：`(T) -> R`

![](./imgs/常用函数式接口01.png)
![](./imgs/常用函数式接口02.png)

### 3、Lambda 表达式中的细节

#### 3.1 类型检查

> Lambda 表达式本身并不包含它在实现哪个函数式接口的信息，其实际类型（或称目标类型）是从使用 Lambda 的上下文推断出来的。
> 
> 同一个 Lambda 表达式可以与不同的函数式接口联系起来，其具体类型需要根据上下文推断。

Lambda 表达式的类型检查过程如下：

![](./imgs/Lambda表达式的类型检查.png)

注意：如果 Lambda 表达式抛出一个异常，那么抽象方法所声明的 throw 语句也必须与之匹配。

#### 3.2 特殊的 void 兼容规则

> 如果一个 Lambda 的主体是一个语句表达式，它就和一个返回 void 的函数描述符兼容。

```Java
// 尽管 List 的 add 方法返回一个 boolean
Consumer<String> consumer = s -> list.add(s);
```

#### 3.3 类型推断

> Java 编译器会从上下文推断出用什么函数式接口来配合 Lambda 表达式，意味着它也可以推断出 Lambda 表达式的参数类型，从而在 Lambda 语法中省去参数类型的标注。

注意：当 Lambda 仅有一个类型需要推断的参数时，参数名称两边的括号也可以省略。

#### 3.4 使用局部变量

> Lambda 表达式允许使用自由变量（外层作用域中定义的变量），但对这些变量有一些限制：
> + 可以没有限制地引用实例变量和静态变量；
> + 引用的局部变量必须显式声明为 final，或事实上就是 final。

提及了**闭包**的概念，好像记得 JavaScript 中有这个概念。

### 4、方法引用

### 5、Lambda 表达式和方法引用的关系

#### 

## 第二部分 函数式数据处理 
## 第三部分 高效 Java 8 编程
## 第四部分 超越 Java 8 

